classdef Motor
    % Class for BLDC Motor

    properties
        K_t (1, 1) double = 0.0707; % Torque Constant
        alpha_Kt (1, 1) double = -0.0006; % Temperature coeffiecient of torque constant 
        K_e (1, 1) double = 0.0707; % relates angular velocity to the voltage generated by the motor 
        alpha_Ke (1, 1) double = -0.0006; temperature 
        I_stall (1, 1) double = 38; % Stall Current, the max current the motor can handle before overheating
        r (1, 1) double {mustBePositive} = 0.113; % Phase resistance of motor
        alpha_r (1, 1) double = 0.0039; % Temperature control of resistance
        lambda_ec (1, 1) double = 0.3; % Eddy Current Loss Coefficient
        alpha_ec (1, 1) double = -0.0001; % Eddy Current Loss with motor temp 
        hys (1, 1) double = 1.0; % Hysteresis lost per cycle
        alpha_hys (1, 1) double = 0; % Hysteresis temperature coeffiecient 
        STC = 23; % Baseline for temperature adjustments 
        M_t (1, 1) double {mustBePositive} = 23; % Current internal temperature of the motor
        eff_lookup     % Efficiency interpolant function
        tau_vec        % Vector of torque values used in the table
        omega_vec      % Vector of speed values used in the table
        eta_grid       % 2D grid of efficiency values

    end

    methods
        function obj = Motor(kt, ke, Is, Ra_t, hy, l_ec, alpha_kt,  alpha_ke, alpha_r, alpha_hy,  alpha_ec, T_init)
             if nargin == 0
        return  % Empty object with default property values
    end
       
            obj.K_t = kt;
            obj.K_e = ke;
            obj.I_stall = Is;
            obj.r = Ra_t;
            obj.hys = hy;
            obj.lambda_ec = l_ec;
            obj.alpha_Kt = alpha_kt;
            obj.alpha_Ke = alpha_ke;
            obj.alpha_r = alpha_r;
            obj.alpha_hys = alpha_hy;
            obj.alpha_ec = alpha_ec;
            obj.M_t = T_init;
        end

        function [P_l, P_lr, P_lh, P_lec] = Get_Power_Loss(obj, tau, omega, ambient)
            % Motor Power Loss at certain torque, speed, and M_terature
            
            P_lr = get_power_loss_resistive(obj, tau);
            P_lh = get_power_loss_hysteresis(obj);
            P_lec = get_power_loss_eddy(obj, omega);
            P_l = P_lr + P_lh + P_lec;
        end
        function [P_lr] = get_power_loss_resistive(obj, tau)
            % Calculate Phase current required for torque
            K_t_at_temp = obj.K_t + obj.alpha_Kt.*(obj.M_t - obj.STC);
            R_eq_at_temp = obj.r + obj.alpha_r.*(obj.M_t - obj.STC);
            I_p = tau./K_t_at_temp/sqrt(2);
            if(I_p > obj.I_stall)
                P_lr = 3*obj.I_stall.^2.*R_eq_at_temp;
            else
                P_lr = 3*I_p.^2.*R_eq_at_temp;
            end
        end
        function [P_lh] = get_power_loss_hysteresis(obj)
            P_lh = obj.hys + obj.alpha_hys.*(obj.M_t - obj.STC);
        end
        function [P_lec] = get_power_loss_eddy(obj, omega)
            P_lec = obj.lambda_ec.*(1 + obj.alpha_ec.*(obj.M_t - obj.STC).*omega);
        end
        
       function obj = build_linear_efficiency_lookup(obj, a, b)
    % Build a linear efficiency lookup: eta = a * (tau + omega) + b

    obj.tau_vec = linspace(0, 5, 100);         % Torque range [Nm]
    obj.omega_vec = linspace(0, 800, 100);     % Speed range [rad/s]

    % Use ndgrid instead of meshgrid for compatibility with griddedInterpolant
    [Tau, Omega] = ndgrid(obj.tau_vec, obj.omega_vec);

    eta = a .* (Tau + Omega) + b;
    eta = max(0, min(1, eta));  % Clamp between 0 and 1

    obj.eta_grid = eta;

    % This now works correctly
    obj.eff_lookup = griddedInterpolant(Tau, Omega, eta, 'linear');
end


function eta = get_efficiency(obj, tau, omega)
    % Returns interpolated efficiency from the lookup table
    if isempty(obj.eff_lookup)
        error('Efficiency lookup not built. Run build_linear_efficiency_lookup() first.');
    end
    eta = obj.eff_lookup(tau, omega);
end

        %function [M_t] = change_motor_M_t(obj, amb)
            % Apply Newton's law of cooling to motor given rotation
            % velocity, power loss, and 
        %end
    end
end
